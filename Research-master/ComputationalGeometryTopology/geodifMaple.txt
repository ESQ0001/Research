with(plots):
with(linalg):
with(plottools):
with(Statistics):

#calculates the length of a curve given its parametric representation and the interval between t0 and t1
longitud:=proc(x,t,t0,t1)
local xp,s,m;
xp:=diff(x,t);
m:=xp[1]^2+xp[2]^2+xp[3]^2;
s:=integrate(sqrt(m),t=t0..t1);
return s;
end proc;

#calculates the point product of u and v vectors
pescalar:=proc(u,v)
local res;
res:=u[1]*v[1]+u[2]*v[2]+u[3]*v[3];
return res;
end proc;

#calculates the vectorial product

pvector:=proc(u,v)
local res;
res:=[0,0,0];
res[1]:=u[2]*v[3]-u[3]*v[2];
res[2]:=u[3]*v[1]-u[1]*v[3];
res[3]:=u[1]*v[2]-u[2]*v[1];
return res;
end proc;

#calculates the osculating planes and returns it in parametric equations

osculap:=proc(x,t,u,v,t0)
local xp,xpp,p,q;
xp :=diff(x,t);
xpp:=diff(xp,t);

p := evalm(subs(t=t0,xp/sqrt(xp[1]^2+xp[3]^2+xp[2]^2)));
q := evalm(subs(t=t0,xpp/sqrt(xpp[1]^2+xpp[3]^2+xpp[2]^2)));



return evalm(subs(t=t0,x)+u*p+v*q);
end proc;

#returns the normal plane
normalp:=proc(x,t,t0)
local xp,xpp,b,p,q;
xp :=diff(x,t);
xpp:=diff(xp,t);
p := evalm(subs(t=t0,xp/sqrt(xp[1]^2+xp[3]^2+xp[2]^2)));
q := evalm(subs(t=t0,xpp/sqrt(xpp[1]^2+xpp[3]^2+xpp[2]^2)));
b:=pvector(p,q);
return evalm(subs(t=t0,x)+u*b+v*q);
end proc;

#returns the rectifying plane
rectifp:=proc(x,t,t0)
local xp,xpp,b,p,q;
xp :=diff(x,t);
xpp:=diff(xp,t);
p := evalm(subs(t=t0,xp/sqrt(xp[1]^2+xp[3]^2+xp[2]^2)));
q := evalm(subs(t=t0,xpp/sqrt(xpp[1]^2+xpp[3]^2+xpp[2]^2)));
b:=pvector(p,q);
print(b,p,q);
return evalm(subs(t=t0,x)+u*p+v*b);
end proc;

#returns the frenet plane

frenet:=proc (x,t,t0)
local xp,xpp,v1,v2,v3,v4;
xp :=diff(x,t);
xpp:=diff(xp,t);
v1:=subs(t=t0,xp);
v2:=subs(t=t0,xpp);
v3:=linalg[crossprod](v1,v2);
v4:=linalg[crossprod](v3,v1);
v1:=evalm(v1/sqrt(v1[1]^2+v1[2]^2+v1[3]^2));
v3:=evalm(v3/sqrt(v3[1]^2+v3[2]^2+v3[3]^2));
v4:=evalm(v4/sqrt(v4[1]^2+v4[2]^2+v4[3]^2));
RETURN([evalm(v1),evalm(v4),evalm(v3)]);
end proc;

#draws the three axes of frenet's frame 

triedro:=proc(x,t,a,b,n,l)
local q,P,c,s,ll;
P:=[seq(0+m*(b-a)/(n-1),m=0..(n-1))];  #Secuencia de n puntos

s:=spacecurve(x,t=a..b,color=blue,thickness=3);  #spacecurve de x

c:=[];
for q from 1 to n do
   c := [op(c),(display({s,
   spacecurve(evalm((subs(t=P[q],x)+t*frenet(x,t,P[q])[1])),t=0..l,color=red,thickness=3),
   spacecurve(evalm((subs(t=P[q],x)+t*frenet(x,t,P[q])[2])),t=0..l,color=cyan,thickness=3),
   spacecurve(evalm((subs(t=P[q],x)+t*frenet(x,t,P[q])[3])),t=0..l,color=green,thickness=3)}))];
end do;
c;
display3d(c,insequence=true,scaling=constrained);
end proc;

#returns the curvature of a curve

flex:=proc(x,t)
local xd,xdd,a,b,c;
xd:=diff(x,t);
xdd:=diff(xd,t);
a:=evalm(crossprod(xd,xdd));
b:=sqrt(a[1]^2+a[2]^2+a[3]^2);
c:=sqrt(xd[1]^2+xd[2]^2+xd[3]^2)^3;
return evalm(b/c);
end proc;

#returns the center of the curvature of a curve

cenrad:= proc(x,t)
local rad,K,n,c;
K:=flex(x,t);
rad:=(1/evalf(K));

n:=(frenet(x,t,t)[2]);

c:=evalm((x)+evalm(rad*n));
return (evalm(c));
end proc;

#returns the torsion of a curve

torsion:=proc(x,t)
local x1,x2,x3,v,p,q,tt;
x1:=diff(x,t);
x2:=diff(x1,t);
x3:=diff(x2,t);
v:=simplify(linalg[crossprod](x1,x2));
p:=linalg[dotprod](v,x3,'orthogonal');
q:=sqrt(v[1]^2+v[2]^2+v[3]^2);

tt:=simplify(p/q^2);
return (tt);
end proc;

#returns the coordinate that results from flipping the curve around the x-axis

giroX:=proc(x,t,alpha)
return [x[1],cos(alpha)*x[2]-sin(alpha)*x[3],sin(alpha)*x[2]+cos(alpha)*x[3]];
end proc;

#returns the coordinate that results from flipping the curve around the y-axis

giroY:=proc(x,t,alpha)
return [cos(alpha)*x[1]-sin(alpha)*x[3],x[2],sin(alpha)*x[1]+cos(alpha)*x[3]];
end proc;

#returns the coordinate that results from flipping the curve around the z-axis

giroZ:=proc(x,t,alpha)
return [cos(alpha)*x[1]-sin(alpha)*x[2],sin(alpha)*x[1]+cos(alpha)*x[2],x[3]];
end proc;

#examples

s81:=spacecurve(giroX(x80,t,Pi/2),t=0..8*Pi,color=blue,thickness=3,numpoints=1000):
s82:=spacecurve(giroY(x80,t,Pi/2),t=0..8*Pi,color=green,thickness=3,numpoints=1000):
s83:=spacecurve(giroZ(x80,t,Pi/2),t=0..8*Pi,color=red,thickness=3,numpoints=1000):


display(s81,s82,s83);

#creates an animation of a flip around the z-axis
cc:=[];
for q from 1 to 36 do
   xn:=giro(x80,t,Pi/12,0,2*Pi*q/36);
   #xn:=giro(x80,t,0,0,2*Pi*q/36);
   cc := [op(cc),spacecurve(xn,t=0..8*Pi,color=blue,thickness=3,view=[-50..50,-50..50,0..50],numpoints=1000)]:
end do:

display(cc,insequence=true);

#returns the surface generated by a flip around the x (e=1), y (e=2), z axis (e=3) axis
rev:=proc(x,t,e)
local sx;
if(e=1)then
return [x[1],sqrt(x[2]^2+x[3]^2)*cos(u),sqrt(x[2]^2+x[3]^2)*sin(u)];
elif(e=2) then
return [sqrt(x[1]^2+x[3]^2)*cos(u),x[2],sqrt(x[1]^2+x[3]^2)*sin(u)];
elif(e=3) then
return [sqrt(x[1]^2+x[2]^2)*cos(u),sqrt(x[1]^2+x[2]^2)*sin(u),x[3]];
end if;
end proc;


#returns the tangent plane

ptan:=proc(x,u,v,u0,v0)
local difu,difv,p,q;
difu:=diff(x,u);
difv:=diff(x,v);
p := evalm(subs(u=u0,v=v0,difu/sqrt(difu[1]^2+difu[2]^2+difu[3]^2)));
q := evalm(subs(u=u0,v=v0,difv/sqrt(difv[1]^2+difv[2]^2+difv[3]^2)));
return evalm(subs(u=u0,v=v0,x)+u*p+v*q);
end proc;

#returns the normal vector to a surface

vnor:=proc(x,u,v)
local difu,difv,n;
difu:=diff(x,u);
difv:=diff(x,v);
n:=[-difu[2]*difv[3]+difv[2]*difu[3] , difu[1]*difv[3]-difv[1]*difu[3] , -difu[1]*difv[2]+difv[1]*difu[2]];
n:=evalm(n/norm(n,2));

return evalm(n);
end proc;

#returns the coefficients from the first quadratic form
formal:=proc(x,u,v)
local difu,difv;
global E,F,G;
difu:=diff(x,u);
difv:=diff(x,v);
E:=evalf(difu[1]^2+difu[2]^2+difu[3]^2):
F:=evalf(difu[1]*difv[1]+difu[2]*difv[2]+difu[3]*difv[3]):
G:=evalf(difv[1]^2+difv[2]^2+difv[3]^2):
return E,F,G;
end proc;

#examples

cono:=[a*u*sin(v),b*u*cos(v),c*u];

cilindro:=[a*sin(v),b*cos(v),c*u];

esfera:=[r*cos(u)*cos(v),r*cos(v)*sin(u),r*sin(v)];

formal(cono,u,v);

formal(cilindro,u,v);

formal(esfera,u,v);

#returns the surface area of a curve x defined by the parameters u and v in a curve determined by a b c d

area:=proc(x,u,a,b,v,c,d)
local dA,A;
formal(x,u,v);
dA:=sqrt(E*G-F^2);
A:=int (int (dA,v=c..d),u=a..b);
return evalf(A);
end proc;


#returns the coefficients from the second quadratic form

forma2:=proc(x,u,v)
local xu,xv,xuu,xuv,xvv,N;
global e,f,g;
xu:=diff(x,u);
xv:=diff(x,v);
xuu:=diff(xu,u);
xuv:=diff(xu,v);
xvv:=diff(xv,v);
N:=[-xu[2]*xv[3]+xv[2]*xu[3] , xu[1]*xv[3]-xv[1]*xu[3] , -xu[1]*xv[2]+xv[1]*xu[2]];
N:=evalm(N/norm(N,2));
e:=innerprod(xuu,N);
f:=innerprod(xuv,N);
g:=innerprod(xvv,N);
return simplify(evalm([e,f,g]));
end proc;

#returns the gaussian curvature
gauss:=proc(x,u,v)
local K,E,F,G,e,f,g;
E:=simplify(evalm(forma1(x,u,v)[1]));
F:=simplify(evalm(forma1(x,u,v)[2]));
G:=simplify(evalm(forma1(x,u,v)[3]));
#[E,F,G]:=evalm(forma1(x,u,v));
e:=simplify(evalm(forma2(x,u,v)[1]));
f:=simplify(evalm(forma2(x,u,v)[2]));
g:=simplify(evalm(forma2(x,u,v)[3]));
K:=simplify(evalf((e*g-f^2)/(E*G-F^2)));
return K;
end proc;

#returns the median curvature

media:=proc(x,u,v)
local M,E,F,G,e,f,g;
E:=simplify(evalm(forma1(x,u,v)[1]));
F:=simplify(evalm(forma1(x,u,v)[2]));
G:=simplify(evalm(forma1(x,u,v)[3]));
#[E,F,G]:=evalm(forma1(x,u,v));
e:=simplify(evalm(forma2(x,u,v)[1]));
f:=simplify(evalm(forma2(x,u,v)[2]));
g:=simplify(evalm(forma2(x,u,v)[3]));
M:=simplify(evalm((g*E+G*e-2*F*f)/2*(E*G-F^2)));
return M;
end proc;

pardis:=proc(x,w,u,v)
local xu,wu,wn,norma,vect,p;
xu:=diff(x,u);
wu:=diff(w,u);
#calculamos la norma de w para normalizarlo
norma:=evalf(sqrt(x[1]^2+x[2]^2+x[3]^2));
wn:=evalm(w/norma);# aqui tenemos w normalizado
vect:=pvector(wu,w);
p:=simplify(evalf(pescalar(xu,vect)));

return simplify(evalm(p));
end proc;

#returns kappa1 and kappa2 (principal curvatures)
principales:=proc(x,u,v)
local M,E,F,G,e,f,g,sol;
sol:=[];
E:=simplify(evalm(forma1(x,u,v)[1]));
#print (E);
F:=simplify(evalm(forma1(x,u,v)[2]));
G:=simplify(evalm(forma1(x,u,v)[3]));
e:=simplify(evalm(forma2(x,u,v)[1]));
f:=simplify(evalm(forma2(x,u,v)[2]));
g:=simplify(evalm(forma2(x,u,v)[3]));
M:=Matrix([[X^2,-X,1],[E,F,G],[e,f,g]]);
sol:= [solve(det(M)=0,X)];
#print( nops(sol));
if(nops(sol)=1)then
sol:=[op(sol),op(sol)];
end if;
return sol;
end proc;

#calculates the normal,the surface and a plane of the normal beam

haz:= proc(x,u,v,u0,v0,theta)
local xu,xv,w,N,x0,e1,e2,M,s,L,difu,difv;
global p,q,y;
difu:=diff(x,u);
difv:=diff(x,v);
xu:=subs(u=u0,v=v0,difu);
xv:=subs(u=u0,v=v0,difv);
x0:=subs(u=u0,v=v0,x);
N:=linalg[crossprod](xu,xv);
N:=evalm(N/sqrt(N[1]^2+N[2]^2+N[3]^2));
e1:=evalm(xu/sqrt(xu[1]^2+xu[2]^2+xu[3]^2));
e2:=linalg[crossprod](N,e1);
L:=evalm(e1*cos(theta)+e2*sin(theta));
y:=evalm([p*N[1]+q*L[1]+x0[1], p*N[2]+q*L[2]+x0[2], p*N[3]+q*L[3]+x0[3]]);
return simplify((evalm (y)));
end proc;

#example of an animation to illustrate the "haz" method

x41:=[u*sin(v),u*cos(v),u];
                    [u sin(v), u cos(v), u]
s41:=plot3d(x41,u=0..2,v=0..2*Pi,style=patchnogrid):
p0:=evalf(subs(u=1,v=Pi/3,x41)):
xu:=evalf(subs(u=1,v=Pi/3,diff(x,u))):
xv:=evalf(subs(u=1,v=Pi/3,diff(x,v))):
p1:=linalg[crossprod](xu,xv):

ar:=plots[arrow](convert(p0,vector),convert(p1,vector),shape=cylindrical_arrow,color =red):
s2:=display(ar):
s:=[]:
for k from 1 to 20 do
t:=2*Pi*k/20;
s43:=plot3d(simplify(haz(x41,u,v,1,Pi/3,t)),p=-1..1,q=-1..1):
s:=[op(s),display(s41,s43,s2)]:
od:


display(s,insequence=true);


#given a point and a surface x(u,v) draws the two-dimensional graph of the normal curvature as a function of alpha
cnormal := proc (x,u,v,u0,v0)
local lambda1,lambda2,kappa1,kappa2,E,F,G,e,f,g;
E:=simplify(evalm(forma1(x,u,v)[1]));
F:=simplify(evalm(forma1(x,u,v)[2]));
G:=simplify(evalm(forma1(x,u,v)[3]));
e:=simplify(evalm(forma2(x,u,v)[1]));
f:=simplify(evalm(forma2(x,u,v)[2]));
g:=simplify(evalm(forma2(x,u,v)[3]));
lambda1:= principales(x,u,v)[1];
lambda2:= principales(x,u,v)[2];
kappa1:=simplify(evalf((e+2*f*lambda1+g*lambda1^2)/(E+2*F*lambda1+G*lambda1^2)));
kappa2:=simplify(evalf((e+2*f*lambda2+g*lambda2^2)/(E+2*F*lambda2+G*lambda2^2)));
return plot(kappa1*cos(alp)^2+kappa2*sin(alp)^2,alp=0..2*Pi);
end proc;

#returns the principal directions

DirPrin:=proc(x,u,v)
local M,E,F,G,e,f,g,sol;
sol:=[];
E:=simplify(evalm(forma1(x,u,v)[1]));
#print (E);
F:=simplify(evalm(forma1(x,u,v)[2]));
G:=simplify(evalm(forma1(x,u,v)[3]));
e:=simplify(evalm(forma2(x,u,v)[1]));
f:=simplify(evalm(forma2(x,u,v)[2]));
g:=simplify(evalm(forma2(x,u,v)[3]));
M:=Matrix([[X^2,-X,1],[E,F,G],[e,f,g]]);
sol:= [solve(det(M)=0,X)];
#print( nops(sol));
if(nops(sol)=1)then
sol:=[op(sol),op(sol)];
end if;
return sol;
end proc;


paralela:=proc(x,u,v,a)
local xu, xv, N;
xu:=diff(x,u);
xv:=diff(x,v);
N:=linalg[crossprod](xu,xv);
N:=evalm(N/sqrt(N[1]^2+N[2]^2+N[3]^2));
return evalm(x+evalm(N*a));
end proc;

#structure used to save the values of the frist and second quadrtic form 

christo:=proc(E,F,G,u,v)
local Eu,Ev,Fu,Fv,Gu,Gv,Ch1,Ch2,aux,i,j,k;
Eu:=diff(E,u);
Ev:=diff(E,v);
Fu:=diff(F,u);
Fv:=diff(F,v);
Gu:=diff(G,u);
Gv:=diff(G,v);
aux:=2*(E*G-F^2);
#CALCULO DE LOS SIMBOLOS DE PRIMERA ESPECIE
Ch1[1,1,1]:=Eu/2;
Ch1[1,1,2]:=Fu-Ev/2;
Ch1[1,2,1]:=Ev/2;
Ch1[1,2,2]:=Gu/2;
Ch1[2,1,1]:=Ev/2;
Ch1[2,1,2]:=Gu/2;
Ch1[2,2,1]:=Fv-Gu/2;
Ch1[2,2,2]:=Gv/2;
#CALCULO DE LOS SIMBOLOS DE SEGUNDA ESPECIE
Ch2[1,1,1]:=evalm((G*Eu-2*F*Fu+F*Ev)/aux);
Ch2[1,1,2]:=evalm((2*E*Fu-E*Ev-F*Eu)/aux);
Ch2[1,2,1]:=evalm(G*Ev-F*Gu/aux);
Ch2[2,1,1]:=evalm(G*Ev-F*Gu/aux);
Ch2[1,2,2]:=evalm((E*Gu-F*Ev)/aux);
Ch2[2,1,2]:=evalm((E*Gu-F*Ev)/aux);
Ch2[2,2,1]:=evalm((2*G*Fv-G*Gu-F*Gv)/aux);
Ch2[2,2,2]:=evalm(E*Gv-2*F*Fv+f*Gu);

for i from 1 to 2 do
for j from 1 to 2 do
for k from 1 to 2 do
print (ch1[i,j,k]= Ch1[i,j,k]);

end do;
end do;
end do;
for i from 1 to 2 do
for j from 1 to 2 do
for k from 1 to 2 do
print (ch2[i,j,k]= Ch2[i,j,k]);
od;
od;
od;
end proc;

#returns the gaussian curvature using Brioschi's formula

brioschi:=proc(E,F,G,u,v)
local K,Eu,Fu,Gu,Ev,Fv,Gv,Euu,Fuu,Guu,Euv,Fuv,Guv,Evv,Fvv,Gvv,M1,M2,D1,D2;
Eu:=diff(E,u);
Ev:=diff(E,v);
Euu:=diff(Eu,u);
Euv:=diff(Ev,u);
Evv:=diff(Ev,v);
Fu:=diff(F,u);
Fv:=diff(F,v);
Fuu:=diff(Fu,u);
Fuv:=diff(Fv,u);
Fvv:=diff(Fv,v);
Gu:=diff(G,u);
Gv:=diff(G,v);
Guu:=diff(Gu,u);
Guv:=diff(Gv,u);
Gvv:=diff(Gv,v);
M1:=Matrix([[(-Evv/2+Fuv-Guu/2),Eu/2,Fu-Ev/2], [Fv-Gu/2,E,F], [Gv/2,F,G]]);
M2:=Matrix([[0,Ev/2,Gu/2], [Ev/2,E,F], [Gu/2,F,G]]);
D1:=simplify(det(M1));
D2:=simplify(det(M2));
K:=(D1-D2)/(E*G-F^2)^2;
return simplify(K);

end proc;

#returns the geodesic curvature when u is constant 

Kgu:=proc(x,u,v)
local Kg,E,F,G,Eu,Ev,Fu,Fv,Gu,Gv,Gamma112,Gamma221;
E:=forma1(x,u,v)[1];
F:=forma1(x,u,v)[2];
G:=forma1(x,u,v)[3];
Eu:=diff(E,u);
Ev:=diff(E,u);
Fu:=diff(F,u);
Fv:=diff(F,v);
Gu:=diff(G,u);
Gv:=diff(G,v);
Gamma112:=(2*E*Fu-E*Ev-F*Eu)/2*(E*G-F^2);
Gamma221:=(2*G*Fv-G*Gu-F*Gv)/2*(E*G-F^2);
Kg:=-Gamma221*sqrt(E*G-F^2)/G*sqrt(G);
return Kg;
end proc;

#returns the geodesic curvature when v is constant 

Kgv:=proc(x,u,v)
local Kg,E,F,G,Eu,Ev,Fu,Fv,Gu,Gv,Gamma112,Gamma221;
E:=forma1(x,u,v)[1];
F:=forma1(x,u,v)[2];
G:=forma1(x,u,v)[3];
Eu:=diff(E,u);
Ev:=diff(E,u);
Fu:=diff(F,u);
Fv:=diff(F,v);
Gu:=diff(G,u);
Gv:=diff(G,v);
Gamma112:=(2*E*Fu-E*Ev-F*Eu)/2*(E*G-F^2);
Gamma221:=(2*G*Fv-G*Gu-F*Gv)/2*(E*G-F^2);
Kg:=Gamma112*sqrt(E*G-F^2)/E*sqrt(E);
return Kg;
end proc;

#given a surface and a curve in implicit form the method returns the geodesic curvature using Bonnet's formula.

cgeo:=proc(x,u,v,h)
local Kg,hu,hv,Monstruo1,Monstruo2,E,F,G;
hu:=diff(h,u);
hv:=diff(h,v);
E:=forma1(x,u,v)[1];
F:=forma1(x,u,v)[2];
G:=forma1(x,u,v)[3];
Monstruo1:=((F*hv-G*hu)/sqrt(E*hv^2-2*F*hu*hv+G*hu^2)+(F*hv-G*hu)/sqrt(E*hv^2-2*F*hu*hv+G*hu^2));
Monstruo2:=((F*hu-E*hv)/sqrt(E*hv^2-2*F*hu*hv+G*hu^2)+(F*hv-G*hu)/sqrt(E*hv^2-2*F*hu*hv+G*hu^2));
Kg:=1/sqrt(E*G-F^2)*
(diff(Monstruo1,u)
+diff(Monstruo2,v));
return simplify(Kg);
end proc;

